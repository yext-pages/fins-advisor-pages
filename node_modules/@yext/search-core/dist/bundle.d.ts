/**
 * AdditionalHttpHeaders allows users to specify additional values for specific HTTP headers.
 *
 * @public
 **/
export declare interface AdditionalHttpHeaders {
    /** {@inheritDoc ClientSDKHeaderValues} */
    'Client-SDK'?: ClientSDKHeaderValues;
}

/**
 * An interface with address fields to use in {@link BaseFieldValueDirectAnswer.value}.
 *
 * @public
 */
export declare interface Address {
    line1?: string;
    line2?: string;
    line3?: string;
    sublocality?: string;
    city?: string;
    region?: string;
    postalCode?: string;
    extraDescription?: string;
    countryCode: string;
}

/**
 * A {@link BaseFieldValueDirectAnswer} interface with 'address' field type.
 *
 * @public
 */
export declare interface AddressDirectAnswer extends BaseFieldValueDirectAnswer<Address> {
    fieldType: EnumOrLiteral<BuiltInFieldType.Address>;
}

/**
 * A direct answer for an android app url field.
 *
 * @public
 */
export declare interface AndroidAppUrlDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: EnumOrLiteral<BuiltInFieldType.AndroidAppURL>;
}

/**
 * A filter that the Search API applied to the search.
 *
 * @public
 */
export declare interface AppliedQueryFilter {
    /**
     * The display name of the filter key.
     *
     * @example
     * 'Job Category'
     */
    displayKey: string;
    /**
     * The value used in the filter.
     *
     * @example
     * 'Sales'
     */
    displayValue: string;
    /** The filter applied to the query results. */
    filter: FieldValueFilter;
    /** {@inheritDoc AppliedQueryFilterType} */
    type: AppliedQueryFilterType;
    /** {@inheritDoc LocationFilterDetails} */
    details?: LocationFilterDetails;
}

/**
 * Represents the type of {@link AppliedQueryFilter} applied to a search.
 *
 * @public
 */
export declare enum AppliedQueryFilterType {
    /** Indicates that a field value filter is applied based on the query. */
    FieldValue = "FIELD_VALUE",
    /** Indicates that a location filter is applied based on the query. */
    Place = "PLACE",
    /** Indicates that a search intent filter is applied based on the query. */
    Intent = "INTENT"
}

/**
 * The response of a universal or vertical autocomplete request.
 *
 * @public
 */
export declare interface AutocompleteResponse {
    /** An array of {@link AutocompleteResult}s. */
    results: AutocompleteResult[];
    /** {@inheritDoc SearchIntent} */
    inputIntents: SearchIntent[];
    /** The ID of the search query. */
    queryId?: string;
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * An autocomplete suggestion.
 *
 * @public
 */
export declare interface AutocompleteResult {
    /** The value of an autocomplete suggestion. */
    value: string;
    /**
     * A filter applied to the autocomplete response.
     *
     * @remarks
     * This property is only defined for filtersearch.
     */
    filter?: FieldValueFilter;
    /**
     * The fieldId which corresponds to the AutocompleteResult value.
     *
     * @remarks
     * This property is only defined for filtersearch.
     */
    key?: string;
    /**
     * An array of substrings which overlap with the autocomplete input.
     *
     * @remarks
     * Offset indicates the index of the match, and the length indicates the number of characters of the match.
     */
    matchedSubstrings?: {
        length: number;
        offset: number;
    }[];
    /**
     * An entity that corresponds to the autocomplete result.
     *
     * @remarks
     * This property is only defined if the corresponding
     * {@link SearchParameterField.fetchEntities} field is true.
     */
    relatedItem?: Result;
    /**
     * Any vertical keys associated with a prompt.
     * This only shows up on universal autocomplete requests.
     **/
    verticalKeys?: string[];
}

/**
 * A service for autocomplete requests.
 *
 * @public
 */
export declare interface AutocompleteService {
    /**
     * Retrieves query suggestions for universal.
     */
    universalAutocomplete(request: UniversalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Retrieves query suggestions for a vertical.
     */
    verticalAutocomplete(request: VerticalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Retrieves query suggestions for filter search.
     */
    filterSearch(request: FilterSearchRequest): Promise<FilterSearchResponse>;
}

/**
 * A direct answer which was found within a document.
 *
 * @public
 */
export declare interface BaseFeaturedSnippetDirectAnswer<T = unknown> extends DirectAnswer<T> {
    /** {@inheritDoc DirectAnswerType.FeaturedSnippet} */
    type: DirectAnswerType.FeaturedSnippet;
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: EnumOrLiteral<BuiltInFieldType.MultiLineText | BuiltInFieldType.RichText>;
    /** The snippet where the direct answer was found. */
    snippet: Snippet;
}

/**
 * A direct answer where the answer came from a field from the knowledge graph.
 *
 * @public
 */
export declare interface BaseFieldValueDirectAnswer<T = unknown> extends DirectAnswer<T> {
    /** {@inheritDoc DirectAnswerType.FieldValue} */
    type: DirectAnswerType.FieldValue;
    /** The result of the direct answer. */
    value: T;
    /** The name of the entity that direct answer came from. */
    entityName: string;
    /** The field name of the direct answer. */
    fieldName: string;
    /** The field api name of the direct answer. */
    fieldApiName: string;
}

/**
 * The base configuration options for {@link SearchCore}.
 * @public
 */
export declare interface BaseSearchConfig {
    /** The experience key of the search experience. */
    experienceKey: string;
    /** The locale of the search experience. */
    locale: string;
    /**
     * The version of the search experience configuration.
     *
     * @remarks
     * May be a configuration label (string) or a configuration version (number).
     *
     * @example
     * Examples: 'PRODUCTION', 42
     */
    experienceVersion?: 'STAGING' | 'PRODUCTION' | string | number;
    /** {@inheritDoc Visitor} */
    visitor?: Visitor;
    /**
     * {@inheritDoc Endpoints}
     *
     * @public
     */
    endpoints?: Endpoints;
    /**
     * Additional query params added on to every request.
     *
     * @public
     */
    additionalQueryParams?: {
        [key: string]: string | number | boolean;
    };
}

/**
 * Possible built-in field types for {@link DirectAnswer.fieldType}.
 *
 * @public
 */
export declare enum BuiltInFieldType {
    URL = "url",
    ComplexURL = "complex_url",
    IOSAppURL = "ios_app_url",
    AndroidAppURL = "android_app_url",
    FacebookURL = "facebook_url",
    Email = "email",
    InstagramHandle = "instagram_handle",
    TwitterHandle = "twitter_handle",
    Phone = "phone",
    Address = "address",
    Hours = "hours",
    Decimal = "decimal",
    Integer = "integer",
    SingleLineText = "single_line_text",
    RichText = "rich_text",
    MultiLineText = "multi_line_text"
}

/**
 * Additional agents and their versions used to create the Search experience. The information for these
 * agents is added to the Client-SDK HTTP header along with that of the ANSWERS_CORE agent.
 *
 * @public
 */
export declare interface ClientSDKHeaderValues {
    /** A mapping of the additional agents that are part of the Client-SDK to their versions. */
    [agent: string]: string | undefined;
    /**
     * The ANSWERS_CORE agent should not be supplied. Instead, it will be automatically added to the
     * header and populated with the version of Search Core being used.
     */
    ANSWERS_CORE?: never;
}

/**
 * The shape of a {@link BuiltInFieldType.ComplexURL} DirectAnswer value
 *
 * @public
 */
export declare interface ComplexURL {
    url: string;
    displayUrl?: string;
    preferDisplayUrl: boolean;
}

/**
 * A direct answer for a complex url field.
 *
 * @public
 */
export declare interface ComplexUrlDirectAnswer extends BaseFieldValueDirectAnswer<ComplexURL> {
    fieldType: EnumOrLiteral<BuiltInFieldType.ComplexURL>;
}

/**
 * A static filter composed by combining other static filters with the
 * logical AND operator.
 *
 * @public
 */
export declare interface ConjunctionStaticFilter {
    /** {@inheritDoc FieldValueStaticFilter.kind} */
    kind: 'conjunction';
    /** {@inheritDoc FilterCombinator.AND} */
    combinator: FilterCombinator.AND;
    /** {@inheritDoc DisjunctionStaticFilter.filters} */
    filters: StaticFilter[];
}

/**
 * Used to trigger Search
 * {@link https://hitchhikers.yext.com/tracks/answers-advanced/ans302-query-rules/ | Query Rules}.
 *
 * @remarks
 * May be any valid JSON object
 *
 * @public
 */
export declare type Context = any;

/**
 * An interface for a day's hours to use in {@link BaseFieldValueDirectAnswer.value}.
 *
 * @public
 */
export declare interface DayHour {
    openIntervals?: Interval[];
    isClosed?: boolean;
}

/**
 * A direct answer for a decimal field, which is a number represented using a string.
 *
 * @public
 */
export declare interface DecimalDirectAnswer extends BaseFieldValueDirectAnswer<string | string[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.Decimal>;
}

/**
 * A direct answer to a search.
 *
 * @public
 */
export declare interface DirectAnswer<T = unknown> {
    /** The {@link DirectAnswerType}. */
    type: DirectAnswerType;
    /**
     * The value of the direct answer.
     *
     * @remarks
     * A value will not be present if the {@link DirectAnswer."type"} is 'FEATURED_SNIPPET'
     * and {@link DirectAnswer.fieldType} is 'rich_text'.
     */
    value?: T;
    /** The entity associated with the direct answer. */
    relatedResult: Result;
    /** The vertical key of the direct answer. */
    verticalKey: string;
    /** The field type of the direct answer. */
    fieldType: EnumOrLiteral<BuiltInFieldType> | 'unknown';
}

/**
 * Represents the type of direct answer.
 *
 * @public
 */
export declare enum DirectAnswerType {
    /** Indicates that the DirectAnswer is a {@link FeaturedSnippetDirectAnswer}. */
    FeaturedSnippet = "FEATURED_SNIPPET",
    /** Indicates that the DirectAnswer is a {@link FieldValueDirectAnswer}. */
    FieldValue = "FIELD_VALUE"
}

/**
 * The direction of a sort.
 *
 * @public
 */
export declare enum Direction {
    /**
     *  An ascending sort
     *
     * @remarks
     * For numbers this sort is low to high. For text it is alphabetical. For dates it is chronological order.
     */
    Ascending = "ASC",
    /**
     * A descending soft
     *
     * @remarks
     * For numbers this sort is high to low. For text it is reverse alphabetical. For dates it is reverse
     * chronological order.
     */
    Descending = "DESC"
}

/**
 * A static filter composed by combining filters with the logical OR
 * operator. The combined filters can either be field value filters or
 * other disjunction filters.
 *
 * @public
 */
export declare interface DisjunctionStaticFilter {
    /** {@inheritDoc FieldValueStaticFilter.kind} */
    kind: 'disjunction';
    /** {@inheritDoc FilterCombinator.OR} */
    combinator: FilterCombinator.OR;
    /** The filters to combine together. */
    filters: (DisjunctionStaticFilter | FieldValueStaticFilter)[];
}

/**
 * A {@link Facet} which contains extra fields meant to be displayed to the end user.
 *
 * @public
 */
export declare interface DisplayableFacet extends Facet {
    /** An array of {@link DisplayableFacetOption} */
    options: DisplayableFacetOption[];
    /** The name of the facet which is meant to be displayed to the user. */
    displayName: string;
}

/**
 * A {@link FacetOption} with extra data meant to be displayed to the end user.
 *
 * @public
 */
export declare interface DisplayableFacetOption extends FacetOption {
    /** The name of the facet option which is meant  to be displayed to the end user. */
    displayName: string;
    /** The number of results associated with this facet option. */
    count: number;
    /** Whether or not the filter is selected in the search results. */
    selected: boolean;
}

/**
 * A {@link BaseFieldValueDirectAnswer} interface with 'email' field type.
 *
 * @public
 */
export declare interface EmailDirectAnswer extends BaseFieldValueDirectAnswer<string[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.Email>;
}

/**
 * Overrides for the URLs which are used when making requests to the Search API.
 *
 * @public
 */
export declare interface Endpoints {
    universalSearch?: string;
    verticalSearch?: string;
    questionSubmission?: string;
    status?: string;
    universalAutocomplete?: string;
    verticalAutocomplete?: string;
    filterSearch?: string;
}

/**
 * Produces a union type from the enum passed as a generic which consists of the enum values
 * and the string literals of the enum.
 *
 * @public
 */
export declare type EnumOrLiteral<T extends string> = T | `${T}`;

/**
 * Identifier for the type of error causing the failure.
 *
 * @public
 */
export declare enum ErrorType {
    /** A timeout error from the server. */
    Timeout = "TIMEOUT",
    /** An internal error from the API backend. */
    BackendError = "BACKEND_ERROR",
    /** An invalid config from the request. */
    InvalidConfig = "INVALID_CONFIG",
    /** An invalid query from the request. */
    InvalidQuery = "INVALID_QUERY"
}

/**
 * A direct answer for a facebook url field.
 *
 * @public
 */
export declare interface FacebookUrlDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: EnumOrLiteral<BuiltInFieldType.FacebookURL>;
}

/**
 * Represents dynamic filter options for the Search API.
 *
 * @public
 */
export declare interface Facet {
    /** The associated fieldId. */
    fieldId: string;
    /**
     * An array of {@link FacetOption}
     *
     * @remarks
     * To indicate that a facet should be disabled, supply an empty array
     */
    options: FacetOption[];
}

/**
 * A filter associated with the facet.
 *
 * @public
 */
export declare interface FacetOption extends Omit<FieldValueFilter, 'fieldId'> {
    /**
     * The value to compare.
     *
     * @example
     * 'Sales'
     */
    value: Exclude<FieldValueFilter['value'], NearFilterValue>;
}

/**
 * Error information from when a vertical fails to return results.
 *
 * @public
 */
export declare interface FailedVertical {
    /** The vertical key associated with the failed vertical. */
    verticalKey: string;
    /** {@inheritDoc ErrorType} */
    errorType: ErrorType;
    /** The duration of the query in milliseconds. */
    queryDurationMillis: number;
    /** Detailed information about the error. */
    details: {
        /**
         * An HTTP response status code indicating the completion status of
         * the request.
         */
        responseCode: number;
        /** A message explaining the error. */
        description: string;
    };
}

/**
 * All possible built-in {@link BaseFeaturedSnippetDirectAnswer} interfaces.
 *
 * @public
 */
export declare type FeaturedSnippetDirectAnswer = MultiLineTextSnippetDirectAnswer | RichTextSnippetDirectAnswer;

/**
 * Possible built-in and custom {@link BaseFieldValueDirectAnswer} interfaces.
 *
 * @public
 */
export declare type FieldValueDirectAnswer = UnknownFieldValueDirectAnswer | TextDirectAnswer | UrlDirectAnswer | RichTextDirectAnswer | DecimalDirectAnswer | FacebookUrlDirectAnswer | InstagramHandleDirectAnswer | TwitterHandleDirectAnswer | IosAppUrlDirectAnswer | AndroidAppUrlDirectAnswer | ComplexUrlDirectAnswer | IntegerDirectAnswer | PhoneDirectAnswer | EmailDirectAnswer | AddressDirectAnswer | HoursDirectAnswer;

/**
 * Represents a filter which compares values to a single field.
 *
 * @public
 */
export declare interface FieldValueFilter {
    /**
     * The fieldId to apply the filter against.
     *
     * @example
     * 'c_jobCategory'
     */
    fieldId: string;
    /** {@inheritDoc Matcher} */
    matcher: Matcher;
    /**
     * The value to compare.
     *
     * @example
     * 'Sales'
     */
    value: string | number | boolean | NearFilterValue | NumberRangeValue;
}

/**
 * A {@link FieldValueFilter} with the kind of filter specified
 * to discriminate between static filter types.
 *
 * @public
 */
export declare interface FieldValueStaticFilter extends FieldValueFilter {
    /** The kind of static filter. */
    kind: 'fieldValue';
}

/**
 * Indicates how child filters in a {@link StaticFilter} should be combined.
 *
 * @public
 */
export declare enum FilterCombinator {
    /** Indicates that filters should be combined with a logical AND. */
    AND = "$and",
    /** Indicates that filters should be combined with a logical OR. */
    OR = "$or"
}

/**
 * Options for a filtersearch request.
 *
 * @public
 */
export declare interface FilterSearchRequest extends SearchRequest {
    /** {@inheritDoc UniversalAutocompleteRequest.input} */
    input: string;
    /** {@inheritDoc UniversalAutocompleteRequest.sessionTrackingEnabled} */
    sessionTrackingEnabled?: boolean;
    /** {@inheritDoc VerticalAutocompleteRequest.verticalKey} */
    verticalKey: string;
    /** Determines whether or not the results of the {@link FilterSearchResponse} are separated by field. */
    sectioned: boolean;
    /** An array of {@link SearchParameterField}. */
    fields: SearchParameterField[];
    /** An array of field value filters that should be excluded from filter search results. */
    excluded?: FieldValueFilter[];
}

/**
 * The response of a filtersearch request.
 *
 * @public
 */
export declare interface FilterSearchResponse {
    /**
     * Represents autocomplete results separated by field.
     *
     * @remarks
     * If sectioned is true, the matching filters will be returned in a separate section per field.
     * By default, they are all returned in the same section.
     */
    sections: {
        /** A display label for the field.
         *
         * @remarks
         * When sectioned is false, there's no label since all filters wil be returned in same section.
         */
        label?: string;
        /** An array of {@link AutocompleteResult}s. */
        results: AutocompleteResult[];
    }[];
    /** ID of the account associated with this Search experience. */
    businessId?: string;
    /** {@inheritDoc AutocompleteResponse.queryId} */
    queryId?: string;
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * A mapping of fields to the values emphasized by the Search API.
 *
 * @remarks
 * Only fields that have been marked as highlighted will be present - which may not be
 * all fields of the corresponding {@link Result}'s rawData.
 * Fields that are present will match the rawData's structure and order.
 *
 * @example
 * If a user searches for 'apple', the API will likely match fields that contain
 * the word 'apple'.
 *
 * ```js
 * {
 *   description: {
 *     value: 'likes apple pie and green apples',
 *     matchedSubstrings: [
 *       { offset: 6, length: 5 },
 *       { offset: 26, length: 5 }
 *     ]
 *   },
 *   c_favoriteFruits: [
 *     {
 *       apples: [
 *         {
 *           value: 'Granny Smith',
 *           matchedSubstrings: []
 *         },
 *         {
 *           value: 'Upton Pyne Apple',
 *           matchedSubstrings: [{ offset: 11, length: 5}]
 *         }
 *       ],
 *       pears: [
 *         {
 *           value: 'Callery Pear',
 *           matchedSubstrings: []
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @public
 */
export declare type HighlightedFields = {
    /**
     * A mapping of a field to either an array of HighlightedFields, HighlightedFields for
     * this field's subfields, or a {@link HighlightedValue} for the field.
     *
     * @remarks
     * HighlightedFields is an object of arbitrary shape which contains {@link HighlightedValue} objects.
     */
    [fieldId: string]: HighlightedValue | HighlightedValue[] | HighlightedFields | HighlightedFields[];
};

/**
 * A field value and its substring matches as emphasized by the Search API.
 *
 * @public
 */
export declare interface HighlightedValue {
    /**
     * The value of the field which should be highlighted.
     *
     * @remarks
     * No formatting is applied to this value. This is simply the value that
     * the Search API determined should be highlighted.
     */
    value: string;
    /**
     * An array of substring matches which correspond to the highlighting.
     *
     * @remarks
     * Offset indicates the index of the match, and the length indicates the number of characters of the match.
     *
     * @example
     * A user may search for 'Yext', and the result may include the value
     * 'Yext is a search company'. The matched substrings would correspond
     * to 'Yext' and the matchedSubstrings array would be: `[{ length: 4, offset: 0 }]`
     */
    matchedSubstrings: {
        length: number;
        offset: number;
    }[];
}

/**
 * An interface for holiday hours to use in {@link BaseFieldValueDirectAnswer.value}.
 *
 * @public
 */
export declare interface HolidayHours {
    date: string;
    openIntervals?: Interval[];
    isClosed?: boolean;
    isRegularHours?: boolean;
}

/**
 * An interface for hours fields to use in {@link BaseFieldValueDirectAnswer.value}.
 *
 * @public
 */
export declare interface Hours {
    monday?: DayHour;
    tuesday?: DayHour;
    wednesday?: DayHour;
    thursday?: DayHour;
    friday?: DayHour;
    saturday?: DayHour;
    sunday?: DayHour;
    holidayHours?: HolidayHours[];
    reopenDate?: string;
}

/**
 * A {@link BaseFieldValueDirectAnswer} interface with 'hours' field type.
 *
 * @public
 */
export declare interface HoursDirectAnswer extends BaseFieldValueDirectAnswer<Hours | Hours[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.Hours>;
}

/**
 * A direct answer for an instagram handle field.
 *
 * @public
 */
export declare interface InstagramHandleDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: EnumOrLiteral<BuiltInFieldType.InstagramHandle>;
}

/**
 * A direct answer for an integer field.
 *
 * @remarks
 * `IntegerDirectAnswer`s are only used for built in number fields.
 * Custom number fields use {@link DecimalDirectAnswer} instead.
 *
 * @public
 */
export declare interface IntegerDirectAnswer extends BaseFieldValueDirectAnswer<number> {
    fieldType: EnumOrLiteral<BuiltInFieldType.Integer>;
}

/**
 * An interface for a time interval to use in {@link BaseFieldValueDirectAnswer.value}.
 *
 * @public
 */
export declare interface Interval {
    start?: string;
    end?: string;
}

/**
 * A direct answer for an iOS app url field.
 *
 * @public
 */
export declare interface IosAppUrlDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: EnumOrLiteral<BuiltInFieldType.IOSAppURL>;
}

/**
 * The latitude and longitude of the user making the request.
 * Used to bias the results.
 *
 * @remarks
 * If omitted from a request, Yext will attempt to determine the location.
 *
 * @public
 */
export declare interface LatLong {
    /**
     * Latitude formatted as a decimal degree number.
     *
     * @example
     * `40.741895`
     */
    latitude: number;
    /**
     * Longitude formatted as a decimal degree number.
     *
     * @example
     * `-73.989308`
     */
    longitude: number;
}

/**
 * Information about the user's location.
 *
 * @public
 */
export declare interface LocationBias {
    /** The location's latitude. */
    latitude: number;
    /** The location's longitude. */
    longitude: number;
    /**
     * The name of the location.
     *
     * @example
     * Arlington, Virginia.
     */
    displayName: string;
    /** {@inheritDoc LocationBiasMethod} */
    method: LocationBiasMethod;
}

/**
 * The method used to determine the location.
 *
 * @public
 */
export declare enum LocationBiasMethod {
    /** Location was determined by IP address. */
    Ip = "IP",
    /**
     * Location was supplied by the user's device.
     *
     * @remarks
     * This location bias method is set when a location is supplied in search requests.
     * */
    Device = "DEVICE",
    /**
     * Location is unknown.
     */
    Unknown = "UNKNOWN"
}

/**
 * Location boundaries for a filter with "Place" for its {@link AppliedQueryFilterType}.
 * (e.g. boundary for a locality or region specific location filter)
 *
 * @public
 */
export declare interface LocationBoundingBox {
    /** The location's highest latitude degree. */
    maxLatitude: number;
    /** The location's highest longitude degree. */
    maxLongitude: number;
    /** The location's lowest latitude degree. */
    minLatitude: number;
    /** The location's lowest longitude degree. */
    minLongitude: number;
}

/**
 * Additional details relevant to the filter with "PLACE" for its {@link AppliedQueryFilterType}.
 *
 * @public
 */
export declare interface LocationFilterDetails {
    /** The location's latitude. */
    latitude: number;
    /** The location's longitude. */
    longitude: number;
    /** The location's name. */
    placeName: string;
    /** The location's classification (e.g. locality, region, address). */
    featureTypes: string[];
    /** The location's coordinate boundaries. */
    boundingBox?: LocationBoundingBox;
}

/**
 * The start limit of {@link NumberRangeValue}.
 *
 * @public
 */
export declare interface LowerNumberRangeLimit {
    /** {@link Matcher} for the start limit */
    matcher: Matcher.GreaterThan | Matcher.GreaterThanOrEqualTo;
    /** Value of the limit. */
    value: number;
}

/**
 * A Matcher is a filtering operation.
 *
 * @public
 */
export declare enum Matcher {
    /**
     * An equals comparison.
     *
     * @remarks
     * Compatible with all field types.
     */
    Equals = "$eq",
    /**
     * A not equals comparison.
     *
     * @remarks
     * Compatible with all field types.
     */
    NotEquals = "!$eq",
    /**
     * A less than comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    LessThan = "$lt",
    /**
     * A less than or equal to comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    LessThanOrEqualTo = "$le",
    /**
     * A greater than comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    GreaterThan = "$gt",
    /**
     * A greater than or equal to comparison.
     *
     * @remarks
     * Compatible with integer, float, date, datetime, and time fields.
     */
    GreaterThanOrEqualTo = "$ge",
    /**
     * A comparison of whether an entity is within a certain radius of a certain location.
     *
     * @remarks
     * Only compatible with the builtin.location field.
     */
    Near = "$near",
    /**
     * A limitation of the dataset to a range of values.
     *
     * @remarks
     * Compatible with integer and float.
     */
    Between = "$between"
}

/**
 * A {@link BaseFeaturedSnippetDirectAnswer} with 'multi_line_text' field type.
 *
 * @public
 */
export declare interface MultiLineTextSnippetDirectAnswer extends BaseFeaturedSnippetDirectAnswer<string> {
    /** The value of the direct answer. */
    value: string;
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: EnumOrLiteral<BuiltInFieldType.MultiLineText>;
}

/**
 * A filter value for a filter with a $near {@link Matcher}.
 *
 * @public
 */
export declare interface NearFilterValue {
    /** The radius (in meters) around the latitude and longitude. */
    radius: number;
    /** The latitude of the location. */
    lat: number;
    /** The longitude of the location. */
    lng: number;
}

/**
 * A filter value for a filter with a $between {@link Matcher}.
 *
 * @public
 */
export declare interface NumberRangeValue {
    /** Start limit of the number range value. */
    start?: LowerNumberRangeLimit;
    /** End limit of the number range value. */
    end?: UpperNumberRangeLimit;
}

/**
 * A {@link BaseFieldValueDirectAnswer} interface with phone value.
 *
 * @public
 */
export declare interface PhoneDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: BuiltInFieldType.Phone;
}

/**
 * The entrypoint to the search-core library.
 *
 * @remarks
 * Returns an {@link SearchCore} instance.
 *
 * @param config - The search-core config
 *
 * @public
 */
export declare function provideCore(config: SearchConfig): SearchCore;

/**
 * Data returned from the Search query rules system.
 *
 * @public
 */
export declare interface QueryRulesActionsData {
    /**
     * The unique identifier for this query rule.
     */
    key: string;
    /**
     * The data returned from the query rule.
     */
    data?: Record<string, unknown>;
    /**
     * Any errors returned from the query rule.
     */
    errors?: {
        /**
         * The unique identifier of the function invocation that resulted in this error.
         */
        uuid: string;
        /**
         * The type of the error.
         */
        type: string;
        /**
         * A message describing the error.
         */
        message?: string;
    }[];
}

/**
 * The source of the search request.
 *
 * @public
 */
export declare enum QuerySource {
    /**
     * Indicates that the query was initiated from a standard Search integration.
     */
    Standard = "STANDARD",
    /**
     * Indicates that the query was initiated from a Search Overlay.
     */
    Overlay = "OVERLAY",
    /**
     * Indicates that the query was initiated from visual autocomplete.
     */
    Autocomplete = "AUTOCOMPLETE"
}

/**
 * Describes the ways a search can be executed besides user input.
 *
 * @remarks
 * Used for search analytics. If a user supplied the search query, do not include a QueryTrigger.
 *
 * @example
 * A Search site may be configured to perform a search for 'What services do you offer?' when the page
 * loads. Because that query is a default query rather than a user-supplied query, the Initialize QueryTrigger
 * should be included in the request.
 *
 * @public
 */
export declare enum QueryTrigger {
    /** Indicates that the query was triggered by a default initial search. */
    Initialize = "initialize",
    /** Indicates that the query was suggested by a {@link SpellCheck} response. */
    Suggest = "suggest"
}

/**
 * Options for a QuestionSubmission request.
 *
 * @public
 */
export declare interface QuestionSubmissionRequest extends SearchRequest {
    /** The email of the user that is submitting the question. */
    email: string;
    /** The ID of the entity to associate with the question. */
    entityId: string;
    /** The name of the user. */
    name: string;
    /** The question. */
    questionText: string;
    /** Additional information about the question. */
    questionDescription?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
}

/**
 * A representation of a question submission response.
 *
 * @public
 */
export declare interface QuestionSubmissionResponse {
    /** A unique id which corresponds to the request. */
    uuid: string;
}

/**
 * Submits a custom question to the Search API.
 *
 * @public
 */
export declare interface QuestionSubmissionService {
    /**
     * Submits a question to be answered.
     *
     * @param request - The question, as well as the contact info of the submitter.
     */
    submitQuestion(request: QuestionSubmissionRequest): Promise<QuestionSubmissionResponse>;
}

/**
 * An individual search result.
 *
 * @public
 */
export declare interface Result<T = Record<string, unknown>> {
    /** Raw entity profile data in the shape of key-value pairs. */
    rawData: T;
    /** {@inheritDoc Source} */
    source: Source;
    /** The index of the result among the other results in the search. */
    index?: number;
    /** The name of the result. */
    name?: string;
    /** A description of the result. */
    description?: string;
    /** A hyperlink associated with the result. */
    link?: string;
    /** The result ID which depends on the Result Source. */
    id?: string;
    /** The distance from the user to the result in meters. */
    distance?: number;
    /**
     * The distance from a {@link AppliedQueryFilter} location to the result in meters.
     *
     * @remarks
     * The filter may be an inferred from the search query, or it may be specified
     * explicitly through a facet or static filter on a {@link VerticalSearchRequest}.
     *
     * @example
     * If a user searches for 'Offices in New York' and the VerticalResults contain an
     * `AppliedQueryFilter` for 'New York', the distanceFromFilter value will be from
     * the search result to 'New York'.
     */
    distanceFromFilter?: number;
    /** The {@link HighlightedFields | highlighted fields} emphasized by the api. */
    highlightedFields?: HighlightedFields;
    /** The entity type of the result. */
    entityType?: string;
}

/**
 * A direct answer for a rich text field.
 *
 * @public
 */
export declare interface RichTextDirectAnswer extends BaseFieldValueDirectAnswer<string | string[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.RichText>;
}

/**
 * A {@link BaseFeaturedSnippetDirectAnswer} with 'rich_text' field type.
 * "value" field is omitted for featured snippet direct answer of this field type.
 *
 * @public
 */
export declare interface RichTextSnippetDirectAnswer extends Omit<BaseFeaturedSnippetDirectAnswer<string>, 'value'> {
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: EnumOrLiteral<BuiltInFieldType.RichText>;
}

/**
 * The endpoints to use for sandbox experiences.
 *
 * @public
 */
export declare const SandboxEndpoints: Required<Endpoints>;

/**
 * The main configuration options for {@link SearchCore}.
 * For a full description of the options, see {@link BaseSearchConfig}.
 * The config requires either an apiKey or a token.
 *
 * @public
 */
export declare type SearchConfig = SearchConfigWithApiKey | SearchConfigWithToken;

/**
 * Configuration options for {@link SearchCore}, which includes the
 * options from {@link BaseSearchConfig}, but requires apiKey.
 * @public
 */
export declare interface SearchConfigWithApiKey extends BaseSearchConfig {
    /** The api key of the search experience which will be sent as a query param. */
    apiKey: string;
    /**
     * token should NOT be provided along with apiKey.
     */
    token?: never;
}

/**
 * Configuration options for {@link SearchCore}, which includes the
 * options from {@link BaseSearchConfig}, but requires token.
 * @public
 */
export declare interface SearchConfigWithToken extends BaseSearchConfig {
    /**
     * The authentication token of the search experience
     * which will be passed in the Auth header as a Bearer token.
     */
    token: string;
    /**
     * apiKey should NOT be provided along with token.
     */
    apiKey?: never;
}

/**
 * Provides methods for executing searches, submitting questions, and performing autocompletes.
 *
 * @public
 */
export declare class SearchCore {
    private searchService;
    private questionSubmissionService;
    private autoCompleteService;
    constructor(searchService: SearchService, questionSubmissionService: QuestionSubmissionService, autoCompleteService: AutocompleteService);
    /**
     * Performs a search across all verticals.
     *
     * @remarks
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @param request - Universal search request options
     */
    universalSearch(request: UniversalSearchRequest): Promise<UniversalSearchResponse>;
    /**
     * Performs a search for a single vertical.
     *
     * @remarks
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @param request - Vertical search request options
     */
    verticalSearch(request: VerticalSearchRequest): Promise<VerticalSearchResponse>;
    /**
     * Submits a custom question to the Search API.
     *
     * @remarks
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @param request - Question submission request options
     */
    submitQuestion(request: QuestionSubmissionRequest): Promise<QuestionSubmissionResponse>;
    /**
     * Performs an autocomplete request across all verticals.
     *
     * @remarks
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @param request - Universal autocomplete request options
     */
    universalAutocomplete(request: UniversalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Performs an autocomplete request for a single vertical.
     *
     * @remarks
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @param request - Vertical autocomplete request options
     */
    verticalAutocomplete(request: VerticalAutocompleteRequest): Promise<AutocompleteResponse>;
    /**
     * Performs a filtersearch request against specified fields within a single vertical.
     *
     * @remarks
     * This differs from the vertical autocomplete because the vertical autocomplete
     * operates on all entity fields whereas filtersearch operates only on specified fields.
     * If rejected, the reason will be an {@link SearchError}.
     *
     * @example
     * A site has a 'products' vertical and would like a way to allow the user to narrow down
     * the results by the product name. The site can add a second search bar powered by filtersearch
     * which will include only product names as search suggestions.
     *
     * @param request - filtersearch request options
     */
    filterSearch(request: FilterSearchRequest): Promise<FilterSearchResponse>;
}

/**
 * Represents an error
 *
 * @remarks
 * If the error originates from the Search API, the code and type property will be present.
 *
 * @public
 */
export declare class SearchError extends Error {
    /** The error message. */
    message: string;
    /** Search API error code. */
    code?: number;
    /** Search API error type. */
    type?: string;
    /* Excluded from this release type: __constructor */
}

/**
 * Represents intents from the Search API.
 *
 * @public
 */
export declare enum SearchIntent {
    /** The Search API is requesting a prompt for the user's location. */
    NearMe = "NEAR_ME"
}

/**
 * Indicates which entity field to perform the autocomplete request on.
 *
 * @public
 */
export declare interface SearchParameterField {
    /** The fieldApiName to perform the autocomplete on. */
    fieldApiName: string;
    /** The entityType to perform the autocomplete on. */
    entityType: string;
    /**
     * Indicates whether or not to return the {@link AutocompleteResult.relatedItem}
     * associated with the autocomplete result.
     */
    fetchEntities: boolean;
}

/**
 * Options for a Search API request.
 *
 * @public
 */
export declare interface SearchRequest {
    /** {@inheritDoc AdditionalHttpHeaders} */
    additionalHttpHeaders?: AdditionalHttpHeaders;
}

/**
 * A service which performs Yext Search.
 *
 * @public
 */
export declare interface SearchService {
    /**
     * Performs a Universal search across all verticals.
     *
     * @param request - The details of the Universal search request.
     */
    universalSearch(request: UniversalSearchRequest): Promise<UniversalSearchResponse>;
    /**
     * Performs a search across a particular Vertical.
     *
     * @param request - The details of the Vertical search request.
     */
    verticalSearch(request: VerticalSearchRequest): Promise<VerticalSearchResponse>;
}

/**
 * The section of text where a {@link FeaturedSnippetDirectAnswer} was found.
 *
 * @public
 */
export declare interface Snippet {
    /** The snippet's body of text */
    value: string;
    /** The locations in the document text of the {@link DirectAnswer.value} */
    matchedSubstrings: {
        offset: number;
        length: number;
    }[];
}

/**
 * Represents a criterion that can be used to sort results.
 *
 * @remarks
 * Overrides the sort options that are configured on the experience configuration.
 *
 * @public
 */
export declare interface SortBy {
    /** {@inheritDoc SortType} */
    type: SortType;
    /** The field name to sort by. Required if the SortBy type is {@link SortType.Field}. */
    field?: string;
    /** The direction of the sort. Required if the SortBy type is {@link SortType.Field}. */
    direction?: Direction;
}

/**
 * The method of sorting.
 *
 * @public
 */
export declare enum SortType {
    /**
     * Sorts based on a field with the direction specified.
     */
    Field = "FIELD",
    /**
     * Sorts based on entity distance alone.
     */
    EntityDistance = "ENTITY_DISTANCE",
    /**
     * Sorts based on relevance according to the algorithm and, when relevant, location bias.
     */
    Relevance = "RELEVANCE"
}

/**
 * Represents the source of a {@link Result}.
 *
 * @public
 */
export declare enum Source {
    /** The result is from a Knowledge Graph. */
    KnowledgeManager = "KNOWLEDGE_MANAGER",
    /** The result is from Google Custom Search Engine. */
    Google = "GOOGLE_CSE",
    /** The result is from Bing Search Engine. */
    Bing = "BING_CSE",
    /** The result is from Zendesk. */
    Zendesk = "ZENDESK",
    /** The result is from Algolia. */
    Algolia = "ALGOLIA",
    /** The result was from a custom source. */
    Custom = "CUSTOM_SEARCHER"
}

/**
 * A spellcheck response from a search query.
 *
 * @public
 */
export declare interface SpellCheck {
    /** The query that was input into the spell checker. */
    originalQuery: string;
    /** The corrected version of the originalQuery. */
    correctedQuery: string;
    /** The type of spell check. */
    type: SpellCheckType;
    /**
     * An array of substring matches which correspond to the highlighting.
     * Offset indicates the index of the match, and the length indicates the number of characters of the match.
     */
    matchedSubstrings: {
        length: number;
        offset: number;
    }[];
}

/**
 * Represents the type of spell check performed.
 *
 * @public
 */
export declare enum SpellCheckType {
    /** The API is suggesting an alternative query. */
    Suggest = "SUGGEST",
    /** The API is autocorrecting the original query. */
    AutoCorrect = "AUTOCORRECT",
    /** The API may be doing some combination of suggesting or autocorrecting. */
    Combine = "COMBINE"
}

/**
 * Represents a static filter that will be used to refine results.
 *
 * @public
 */
export declare type StaticFilter = FieldValueStaticFilter | DisjunctionStaticFilter | ConjunctionStaticFilter;

/**
 * A direct answer whose source is a string or string list field in the knowledge graph.
 *
 * @public
 */
export declare interface TextDirectAnswer extends BaseFieldValueDirectAnswer<string | string[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.SingleLineText | BuiltInFieldType.MultiLineText>;
}

/**
 * A direct answer for an twitter handle field.
 *
 * @public
 */
export declare interface TwitterHandleDirectAnswer extends BaseFieldValueDirectAnswer<string> {
    fieldType: EnumOrLiteral<BuiltInFieldType.TwitterHandle>;
}

/**
 * Options for a universal autocomplete request.
 *
 * @public
 */
export declare interface UniversalAutocompleteRequest extends SearchRequest {
    /** The input string for autocomplete. */
    input: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
}

/**
 * The maximum limit of results per vertical.
 * Each limit can be set from 1-50, inclusive.
 *
 * @example
 * \{
 *    people: 5,
 *    locations: 10,
 *    events: 8
 * \}
 *
 * @public
 */
export declare interface UniversalLimit {
    [verticalKey: string]: number;
}

/**
 * Options which can be specified for a universal search.
 *
 * @public
 */
export declare interface UniversalSearchRequest extends SearchRequest {
    /** The search query. */
    query: string;
    /** {@inheritDoc QueryTrigger} */
    queryTrigger?: QueryTrigger;
    /** Disables spellcheck if true. */
    skipSpellCheck?: boolean;
    /** Used to track session state when cookies are blocked. */
    sessionId?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
    /** {@inheritDoc LatLong} */
    location?: LatLong;
    /** {@inheritDoc Context} */
    context?: Context;
    /**
     * The URl of the page which referred the user to the current page.
     *
     * @example
     * If a user is on https://www.yext.com/ and navigates to https://search.yext.com/ and perform a search,
     * the referrerPageUrl would be https://www.yext.com/.
     */
    referrerPageUrl?: string;
    /** {@inheritDoc QuerySource} */
    querySource?: QuerySource | string;
    /** {@inheritDoc UniversalLimit} */
    limit?: UniversalLimit;
    /** If included, the response will only include these verticals. */
    restrictVerticals?: string[];
}

/**
 * A representation of a response from a universal search.
 *
 * @public
 */
export declare interface UniversalSearchResponse {
    /** An array of {@link VerticalResults} which represent the results for each vertical. */
    verticalResults: VerticalResults[];
    /** The ID of the search query. */
    queryId?: string;
    /** {@inheritDoc DirectAnswer} */
    directAnswer?: FeaturedSnippetDirectAnswer | FieldValueDirectAnswer;
    /** An array of {@link SearchIntent}s which represents requests from the API. */
    searchIntents?: SearchIntent[];
    /** {@inheritDoc SpellCheck} */
    spellCheck?: SpellCheck;
    /** {@inheritDoc LocationBias} */
    locationBias?: LocationBias;
    /** A unique id which corresponds to the request. */
    uuid: string;
    /** {@inheritDoc QueryRulesActionsData} */
    queryRulesActionsData?: QueryRulesActionsData[];
    /** {@inheritDoc FailedVertical} */
    failedVerticals?: FailedVertical[];
}

/**
 * A {@link BaseFieldValueDirectAnswer} with a field type outside of {@link BuiltInFieldType}.
 *
 * @public
 */
export declare interface UnknownFieldValueDirectAnswer<T = unknown> extends BaseFieldValueDirectAnswer<T> {
    /** {@inheritDoc DirectAnswer.fieldType} */
    fieldType: 'unknown';
}

/**
 * The end limit of {@link NumberRangeValue}.
 *
 * @public
 */
export declare interface UpperNumberRangeLimit {
    /** {@link Matcher} for the end limit */
    matcher: Matcher.LessThan | Matcher.LessThanOrEqualTo;
    /** Value of the limit. */
    value: number;
}

/**
 * A direct answer for a simple url field.
 *
 * @public
 */
export declare interface UrlDirectAnswer extends BaseFieldValueDirectAnswer<string | string[]> {
    fieldType: EnumOrLiteral<BuiltInFieldType.URL>;
}

/**
 * Options for a vertial autocomplete request.
 *
 * @public
 */
export declare interface VerticalAutocompleteRequest extends SearchRequest {
    /** {@inheritDoc UniversalAutocompleteRequest.input} */
    input: string;
    /** {@inheritDoc UniversalAutocompleteRequest.sessionTrackingEnabled} */
    sessionTrackingEnabled?: boolean;
    /** The key for the vertical to get autocomplete suggestions from. */
    verticalKey: string;
}

/**
 * Represents results from a search vertical.
 *
 * @public
 */
export declare interface VerticalResults {
    /** A array of {@link AppliedQueryFilter}s which were applied to the vertical results. */
    appliedQueryFilters: AppliedQueryFilter[];
    /** The duration of the query in milliseconds. */
    queryDurationMillis: number;
    /** An array of search {@link Result}s for the vertical. */
    results: Result[];
    /**
     * The total number of results within the vertical.
     *
     * @remarks
     * This number may be higher than the number of results in the results array
     * since the API limits the number of results returned in each request.
     */
    resultsCount: number;
    /** {@inheritDoc Source} */
    source: Source;
    /** The vertical key associated with the vertical results. */
    verticalKey: string;
}

/**
 * Options which can be specified for a vertical search.
 *
 * @public
 */
export declare interface VerticalSearchRequest extends SearchRequest {
    /** The search query. */
    query: string;
    /** The key associated with the vertical. */
    verticalKey: string;
    /** {@inheritDoc Context} */
    context?: Context;
    /** The maximum number of results to include with a max of 50. */
    limit?: number;
    /** The result offset which allows for fetching more results with the same query. */
    offset?: number;
    /** Indicates that facets should be retrieved. */
    retrieveFacets?: boolean;
    /** The facet filters to apply to the search. */
    facets?: Facet[];
    /** Skips spell checking if true. */
    skipSpellCheck?: boolean;
    /** {@inheritDoc LatLong} */
    location?: LatLong;
    /** {@inheritDoc QueryTrigger} */
    queryTrigger?: QueryTrigger;
    /** Used to track session state when cookies are blocked. */
    sessionId?: string;
    /** Enables session tracking. */
    sessionTrackingEnabled?: boolean;
    /** The static filter to apply to the search. */
    staticFilter?: StaticFilter;
    /** Determines how results are sorted. **/
    sortBys?: SortBy[];
    /** {@inheritdoc UniversalSearchRequest.referrerPageUrl} */
    referrerPageUrl?: string;
    /** {@inheritDoc QuerySource} */
    querySource?: QuerySource | string;
    /** The radius (in meters) to filter the vertical search by. */
    locationRadius?: number;
    /** The queryId for the query, if this is a repeat query. */
    queryId?: string;
}

/**
 * A representation of a response from a vertical search.
 *
 * @public
 */
export declare interface VerticalSearchResponse {
    /** {@inheritDoc VerticalResults} */
    verticalResults: VerticalResults;
    /** The ID of the query. */
    queryId: string;
    /** {@inheritDoc DirectAnswer} */
    directAnswer?: FeaturedSnippetDirectAnswer | FieldValueDirectAnswer;
    /** An array of {@link SearchIntent}s. */
    searchIntents?: SearchIntent[];
    /** An array of {@link Facet}s associated with the search results. */
    facets?: DisplayableFacet[];
    /** {@inheritDoc SpellCheck} */
    spellCheck?: SpellCheck;
    /** {@inheritDoc LocationBias} */
    locationBias?: LocationBias;
    /** {@inheritDoc VerticalSearchResponse} */
    allResultsForVertical?: VerticalSearchResponse;
    /** The {@link VerticalResults} for each search vertical. */
    alternativeVerticals?: VerticalResults[];
    /** A unique id which corresponds to the request. */
    uuid: string;
    /** {@inheritDoc QueryRulesActionsData} */
    queryRulesActionsData?: QueryRulesActionsData[];
}

/**
 * Information used to associate requests with a particular user.
 *
 * @remarks
 * Visitor information is included with every request with the exception of question submission requests.
 *
 * @public
 */
export declare interface Visitor {
    /** The ID associated with the user */
    id: string;
    /** The type of visitor
     *
     * @example 'YEXT_USER' for Yext Auth
     */
    idMethod?: string;
}

export { }
