"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFilterSearchResponse = exports.createAutocompleteResponse = void 0;
const SearchError_1 = require("../../models/searchapi/SearchError");
const createAutocompleteResult_1 = require("./createAutocompleteResult");
function createAutocompleteResponse(data) {
    if (!data.response) {
        throw new Error('The autocomplete data does not contain a response property');
    }
    if (!Object.keys(data.response).length) {
        throw new Error('The autocomplete response is empty');
    }
    const response = data.response;
    const responseResults = response.results.map(createAutocompleteResult_1.createAutocompleteResult);
    const inputIntents = response.input ? response.input.queryIntents : [];
    return {
        results: responseResults,
        queryId: response.queryId,
        inputIntents: inputIntents || [],
        uuid: data.meta.uuid
    };
}
exports.createAutocompleteResponse = createAutocompleteResponse;
function createFilterSearchResponse(data) {
    if (!data.response) {
        throw new Error('The autocomplete data does not contain a response property');
    }
    if (!Object.keys(data.response).length) {
        throw new Error('The autocomplete response is empty');
    }
    const response = data.response;
    if (response.failedVerticals && response.failedVerticals.length != 0) {
        const error = response.failedVerticals[0];
        throw new SearchError_1.SearchError(error.details.description, error.details.responseCode, error.errorType);
    }
    const sections = response.sections.map((section) => ({
        label: section.label,
        results: section.results.map(createAutocompleteResult_1.createAutocompleteResult)
    }));
    return {
        sections: sections,
        queryId: response.queryId,
        businessId: response.businessId,
        uuid: data.meta.uuid
    };
}
exports.createFilterSearchResponse = createFilterSearchResponse;
//# sourceMappingURL=createAutocompleteResponse.js.map